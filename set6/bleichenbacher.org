* p47

Let us Google this for you: "Chosen ciphertext attacks against protocols based on the RSA encryption standard". This is Bleichenbacher from CRYPTO '98; I get a bunch of .ps versions on the first search page.
Read the paper. It describes a padding oracle attack on PKCS#1v1.5. The attack is similar in spirit to the CBC padding oracle you built earlier; it's an "adaptive chosen ciphertext attack", which means you start with a valid ciphertext and repeatedly corrupt it, bouncing the adulterated ciphertexts off the target to learn things about the original. This is a common flaw even in modern cryptosystems that use RSA.
It's also the most fun you can have building a crypto attack. It involves 9th grade math, but also has you implementing an algorithm that is complex on par with finding a minimum cost spanning tree.

The setup:

- Build an oracle function, just like you did in the last exercise, but have it check for plaintext[0] == 0 and plaintext[1] == 2.
- Generate a 256 bit keypair (that is, p and q will each be 128 bit primes), [n, e, d].
- Plug d and n into your oracle function.
- PKCS1.5-pad a short message, like "kick it, CC", and call it "m". Encrypt to to get "c".
- Decrypt "c" using your padding oracle.
- For this challenge, we've used an untenably small RSA modulus (you could factor this keypair instantly). That's because this exercise targets a specific step in the Bleichenbacher paper --- Step 2c, which implements a fast, nearly O(log n) search for the plaintext.

Things you want to keep in mind as you read the paper:
- RSA ciphertexts are just numbers.
- RSA is "homomorphic" with respect to multiplication, which means you can multiply c * RSA(2) to get a c' that will decrypt to plaintext * 2. This is mindbending but easy to see if you play with it in code --- try multiplying ciphertexts with the RSA encryptions of numbers so you know you grok it.

What you need to grok for this challenge is that Bleichenbacher uses multiplication on ciphertexts the way the CBC oracle uses XORs of random blocks.
A PKCS#1v1.5 conformant plaintext, one that starts with 00:02, must be a number between 02:00:00...00 and 02:FF:FF..FF --- in other words, 2B and 3B-1, where B is the bit size of the modulus minus the first 16 bits. When you see 2B and 3B, that's the idea the paper is playing with.

To decrypt "c", you'll need Step 2a from the paper (the search for the first "s" that, when encrypted and multiplied with the ciphertext, produces a conformant plaintext), Step 2c, the fast O(log n) search, and Step 3.

Your Step 3 code is probably not going to need to handle multiple ranges.

We recommend you just use the raw math from paper (check, check, double check your translation to code) and not spend too much time trying to grok how the math works.

* p48

This is a continuation of challenge #47; it implements the complete BB'98 attack.

Set yourself up the way you did in #47, but this time generate a 768 bit modulus.

To make the attack work with a realistic RSA keypair, you need to reproduce step 2b from the paper, and your implementation of Step 3 needs to handle multiple ranges.

The full Bleichenbacher attack works basically like this:

- Starting from the smallest 's' that could possibly produce a plaintext bigger than 2B, iteratively search for an 's' that produces a conformant plaintext.
- For our known 's1' and 'n', solve m1=m0s1-rn (again: just a definition of modular multiplication) for 'r', the number of times we've wrapped the modulus.
- 'm0' and 'm1' are unknowns, but we know both are conformant PKCS#1v1.5 plaintexts, and so are between [2B,3B].
- We substitute the known bounds for both, leaving only 'r' free, and solve for a range of possible 'r' values. This range should be small!
- Solve m1=m0s1-rn again but this time for 'm0', plugging in each value of 'r' we generated in the last step. This gives us new intervals to work with. Rule out any interval that is outside 2B,3B.
- Repeat the process for successively higher values of 's'. Eventually, this process will get us down to just one interval, whereupon we're back to exercise #47.
- What happens when we get down to one interval is, we stop blindly incrementing 's'; instead, we start rapidly growing 'r' and backing it out to 's' values by solving m1=m0s1-rn for 's' instead of 'r' or 'm0'. So much algebra! Make your teenage son do it for you! *Note: does not work well in practice*


* Chosen Ciphertext Attacks Against Protocols
** Front Material
Based on the RSA Encryption Standard
PKCS #1
Daniel Bleichenbacher
Bell Laboratories
700 Mountain Ave., Murray Hill, NJ 07974
bleichen@research.bell-labs.com

** Abstract. 
This paper introduces a new adaptive chosen ciphertext attack
against certain protocols based on RSA. We show that an RSA
private-key operation can be performed if the attacker has access to
an oracle that, for any chosen ciphertext, returns only one bit telling
whether the ciphertext corresponds to some unknown block of data encrypted
using PKCS #1. An example of a protocol susceptible to our
attack is SSL V.3.0.
Keywords: chosen ciphertext attack, RSA, PKCS, SSL

** 1 Overview

In this paper, we analyze the following situation. Let n, e be an RSA public key,
and let d be the corresponding secret key. Assume that an attacker has access to
an oracle that, for any chosen ciphertext c, indicates whether the corresponding
plaintext cd mod n has the correct format according to the RSA encryption
standard PKCS #1.

We show how to use this oracle to decrypt or sign a message. The attacker
carefully prepares ciphertexts that are sent to the oracle. Combining the returns
from the oracle, the attacker gradually gains information on cd. The chosen ciphertexts
are based on previous outcomes of the oracle. Thus, this technique is
an example of an adaptive chosen-ciphertext attack. Usually, a chosen ciphertext
attack is based on the theoretical assumption that the attacker has access to a
decryption device that returns the complete decryption for a chosen ciphertext.
Hence, if a public-key cryptosystem is susceptible to a chosen-ciphertext attack,
that often is considered to be only a theoretical weakness. However, the attack
shown in this paper is practical, because it is easy to get the necessary information
corresponding to the oracle reply. The attack can be carried out if, for
example, the attacker has access to a server that accepts encrypted messages
and returns an error message depending on whether the decrypted message is
PKCS conforming.

This paper is organized as follows. We describe the RSA encryption standard
PKCS #1 in Section 2. In Section 3, we describe and analyze our chosenciphertext
attack. Different situations in which this attack can be carried out

H. Krawczyk (Ed.): CRYPTO’98, LNCS 1462, pp. 1–12, 1998.
c Springer-Verlag Berlin Heidelberg 1998
2 Daniel Bleichenbacher

are listed in Section 4. We then analyze the vulnerability of SSL to our attack in
Section 5. In Section 6, we report experiments with the technique. In Section 7,
we conclude by offering recommendations.

** 2 PKCS #1

In this section, we describe briefly the RSA encryption standard PKCS #1; refer
to [11] for details. Currently, there are three block formats: Block types 0 and 1
are reserved for digital signatures, and block type 2 is used for encryption. We
describe only block type 2, because it is relevant for this paper.

    00 02 padding string 00 data block

Fig. 1. PKCS #1 block format for encryption. The first two bytes in this format
are constant. The length of the padding block can vary.

Let n, e be an RSA public key, and let p, q, d be the corresponding secret key
(i.e, n = pq and d ≡ e−1 (mod ϕ(n))). Moreover, let k be the byte length of n.
Hence, we have 28(k−1) ≤ n < 28k. A data block D, consisting of |D| bytes, is
encrypted as follows. First, a padding string P S, consisting of k−3−|D| nonzero
bytes, is generated pseudo-randomly. Here, |D| must not exceed k − 11; in other
words, the byte length of P S is a least 8. Now, the encryption block EB =
00||02||P S||00||D is formed (Figure 1), is converted into an integer x, and is
encrypted with RSA, giving the ciphertext c ≡ xe (mod n). The representation
of the ciphertext is not important for this paper.
We are, however, interested in how the receiver parses a ciphertext. First, he
gets an integer x0 by decrypting the ciphertext with his private key. Then, he
converts x0 into an encryption block EB0
. Now he looks for the first zero byte,
which indicates the ending of the padding string PS and the start of the data
block D. The following definition specifies when this parsing process is successful.
Definition 1. An encryption block EB consisting of k bytes – that is,
EB = EB1||...||EBk
is called PKCS conforming – if it satisfies the requirements of block type 2 in
PKCS #1. In particular, EB must satisfy the following conditions:
– EB1 = 00.
– EB2 = 02.
– EB3 through EB10 are nonzero.
– At least one of the bytes EB11 through EBk is 00.
Chosen Ciphertext Attacks Against Protocols 3
We also call a ciphertext c PKCS conforming if its decryption is PKCS conforming.
Note that the definition of conforming does not include possible integrity
checks. We show in Section 3 that it should not be possible for an attacker to
decide whether a chosen ciphertext is PKCS conforming. It is sometimes possible
for an attacker to do so even if the data block contains further integrity checks.

** 3 Chosen-Ciphertext Attacks
*** 3.0 Attack Intro
In a chosen-ciphertext attack, the attacker selects the ciphertext, sends it to the
victim, and is given in return the corresponding plaintext or some part thereof. A
chosen-plaintext attack is called adaptive if the attacker can chose the ciphertexts
depending on previous outcomes of the attack.

It is well known that plain RSA is susceptible to a chosen-ciphertext attack
[5]. An attacker who wishes to find the decryption m ≡ cd (mod n) of
a ciphertext c can chose a random integer s and ask for the decryption of the
innocent-looking message c0 ≡ sec mod n. From the answer m0 ≡ (c0)d, it is easy
to recover the original message, because m ≡ m0s−1 (mod n).

Another well-known result is that the least significant bit of RSA encryption
is as secure as the whole message [8] (see also [1]). In particular, there exists an
algorithm that can decrypt a ciphertext if there exists another algorithm that
can predict the least significant bit of a message given only the corresponding
ciphertext and the public key. H˚astad and N¨aslund recently extended this result
to show that all individual RSA bits are secure [9].
Hence, it is not necessary for an attacker to learn the complete decrypted
nmessage in a chosen-ciphertext attack: Single bits per chosen ciphertext may be
snufficient.

The result reported in this paper is similar. We assume that the attacker has
access to an oracle that, for every ciphertext, returns whether the corresponding
plaintext is PKCS conforming. We show that we can use this oracle to compute
cd (mod n) for any chosen integer c. Theoretically, we can use H˚astad’s and
N¨aslund’s algorithm [9] to find c. In this paper, we describe a different algorithm
that has as its goal to minimize the number of chosen ciphertexts; thus, we show
the practicality of the attack. That is, we are not trying to generalize the attack;
rather, we would like to take advantage of specific properties of PKCS #1. In
particular, the algorithm relies on the facts that the first two bytes of the PKCS
#1 format are constant, and that we know these two bytes with certainty when
a ciphertext is accepted. Also, we use heuristic arguments in our the analysis of
the algorithm to approximate the number of expected chosen ciphertexts, rather
than finding an upper bound.

*** 3.1 Description of the Attack

First, we give a short overview over the attack; then, we describe the attack in
detail.

Assume that the attacker wants to find m ≡ c^d (mod n), where c is an
arbitrary integer. Basically, the attacker chooses integers s, computes

     c_0 ≡ cs^e (mod n),

and sends c_0 to the oracle. If the oracle says that c_0 is PKCS conforming, then
the attacker knows that the first two bytes of ms are 00 and 02. For convenience,

    let B = 2^8(k−2)

Recall that k is the length of n in bytes. Hence, that ms is PKCS conforming
implies that

     2B ≤ ms mod n < 3B.

By collecting several such pieces of information, we can eventually derive m.
Typically, 220 chosen ciphertexts will be sufficient, but this number varies widely
depending on numerous implementation details.

The attack can be divided into three phases. In the first phase, the message
is blinded, giving a ciphertext c_0 that corresponds to an unknown message m_0.
In the second phase, the attacker tries to find small values s_i for which the ciphertext
c_0(s_i)^e mod n is PKCS conforming. For each successful value for s_i, the
attacker computes, using previous knowledge about m_0, a set of intervals that
must contain m_0. We elaborate this process later. The third phase starts when
only one interval remains. Then, the attacker has sufficient information about
m0 to choose s_i such that c_0(s_i)^e mod n is much more likely to be PKCS conforming
than is a randomly chosen message. The size of s_i is increased gradually,
narrowing the possible range of m_0 until only one possible value remains.
Now we describe this attack in detail. The variable M_i will always be a set
of (closed) intervals that is computed after a successful si has been found, such
that m_0 is contained in one of the intervals of M_i.

Step 1: Blinding. Given an integer c, choose different random integers s_0; then
check, by accessing the oracle, whether c(s_0)^e mod n is PKCS conforming.

For the first successful value s_0, set

    c_0 ← c(s_0)^e mod n
    M_0 ← {[2B, 3B − 1]}
    i ← 1.

Step 2: Searching for PKCS conforming messages.

Step 2.a: Starting the search. If i = 1, then search for the smallest positive
integer s_1 ≥ n/(3B), such that the ciphertext c_0(s_1)^e mod n is PKCS
conforming.

Step 2.b: Searching with more than one interval left. Otherwise, if i >
1 and the number of intervals in M_i−1 is at least 2, then search for the
smallest integer s_i > s_i−1, such that the ciphertext c_0(s_i)^e mod n is PKCS
conforming.

Step 2.c: Searching with one interval left. Otherwise, if M_i−1 contains exactly
one interval (i.e., M_i−1 = {[a, b]}), then choose small integer values
r_i, s_i such that

    r_i ≥ [2 * (b * s_i−1 − 2B) / n]    (1)

and
    [(2B + r_i * n) / b] ≤ s_i < [(3B + r_i * n) / a]  (2)

until the ciphertext c_0(s_i)^e mod n is PKCS conforming.

Step 3: Narrowing the set of solutions. After si has been found, the set
M_i is computed as

M_i ← Union (a,b,r) {[ max(a, ceil( (2B+rn)/s_i) ),
                       min(b, floor( (3B - 1 + rn) / s_i) )]}    (3)
     for all [a, b] that are elements of M_i-1 and 
     [(a * s_i - 3B + 1) / n] <= r <= [(b * s_i - 2B) / n]

Step 4: Computing the solution. If M_i contains only one interval of length
1 (i.e., M_i = {[a, a]}), then set m ← a(s_0)^−1 mod n, and return m as solution
of m ≡ c^d (mod n). Otherwise, set i ← i + 1 and go to step 2.

Remarks. Step 1 can be skipped if c is already PKCS conforming (i.e., when
c is an encrypted message). In that case, we set s_0 ← 1. However, step 1 is
always necessary for computing a signature, even if we do not wish to get a
blind signature.

In Step 2.a, we start with s_1 = ceil( n/(3B) ), because, for smaller values m_0 * s_1
is never PKCS conforming.

We use condition (1) because we want to divide the remaining interval in
each iteration roughly in half.

We can often improve the attack by using more information. For example,
we have not used the fact that any PKCS-conforming message m0si contains
at least one zero byte. Moreover, if the attack is performed in a client–server
environment, where both parties use the message m0si to generate session keys,
we might be able to find this message by exhaustive search if we already knew
a sufficient portion of it.

** 3.2 Analysis of the Attack

We now analyze the correctness of the attack and approximate the complexity
of, and, in particular, the number of oracle accesses necessary for, this attack.
We must make a few heuristic assumptions; hence, we cannot give a rigorous
proof of our result.

First, we approximate the probability Pr(P) that a randomly chosen integer
0 ≤ m<n is PKCS conforming. Let Pr(A) = B
n be the probability that, for a
6 Daniel Bleichenbacher
randomly chosen integer, the first two bytes are 00 and 02, respectively. Since
we have 216B>n> 28B, it follows that
2−16 < Pr(A) < 2−8.
The RSA modulus is usually chosen to be a multiple of 8; hence, Pr(A) will
usually be close to 2−16. The probability that the padding block PS contains at
least 8 non-zero bytes followed by a zero byte is
Pr(P|A) = 255
2568
·

1 −
255
256k−10!
.
Assuming a modulus n of at least 512 bit (i.e. k ≥ 64), we have
0.18 < Pr(P|A) < 0.97;
hence, we have
0.18 · 2−16 < Pr(P) < 0.97 · 2−8.
Next, we explain why our algorithm finds m0 and thus m. We prove that
m0 ∈ Mi for all i by induction over i. Since m0 is PKCS conforming, we have
2B ≤ m0 ≤ 3B − 1, and so, trivially, m0 ∈ M0.
Now assume that m0 ∈ Mi−1. Hence, there exists an interval [a, b] ∈ Mi−1
with a ≤ m0 ≤ b. Since m0si is PKCS conforming, there exists an integer r such
that 2B ≤ m0si − rn ≤ 3B − 1, and hence asi − (3B − 1) ≤ rn ≤ bsi − 2B. We
also have
2B + rn
si
≤ m0 ≤
3B − 1 + rn
si
.
Hence, it follows from the definition of Mi that m0 is contained in one of the
intervals.
Now we analyze the complexity of the attack. The messages in step 1 are
chosen randomly; therefore, this step needs about 1/Pr(P) accesses to the oracle
on average to find s0. We assume again that, on average, we need 1/Pr(P)
accesses to the oracle to find si for i ≥ 1 in step 2.a and 2.b. (See also the
remark at the end of this section.)
Let ωi be the number of intervals in Mi. Using heuristic arguments, we can
expect that ωi will satisfy the following equation for i ≥ 1.
ωi ≤ 1+2i−1si
B
n
i
(4)
Indeed, the length of an interval in Mi is upper bounded by l
B
si
m
. The knowledge
that m0si is PKCS conforming alone would lead to  siB
n

intervals of the form
Ir =
2B + rn
si

,

3B − 1 + rn
si
 , (5)
since r can take at most  siB
n

values in equation (3).
Chosen Ciphertext Attacks Against Protocols 7
In particular, M1 will contain about  s1B
n

intervals. If i > 1, then each of the
intervals Ir or a fraction of Ir is included in Mi if Ir overlaps with one interval
of Mi−1. No interval Ir can overlap with two intervals in Mi−1. If intervals Ir
were randomly distributed, then the probability that one intersects with Mi−1
would be upper bounded by
 1
si
+
1
si−1

ωi−1.
Hence, we get Equation (4) by taking into account that one interval must contain
m0. In our case, we expect s2 to be approximately 2/Pr(P), and we have
2(B/n)2/Pr(P)=2B/(nPr(P|A)) < 2B/(0.18n) < 1/20. Hence, w2 is 1 with
high probability. Thus, we expect that Step 2.b will be executed only once.
Now we analyze Step 2.c. We have Mi = {[a, b]}; hence, a ≤ m0 ≤ b, and
thus
2B + rin
b ≤
2B + rin
m0
≤ si ≤
3B − 1 + rin
m0
≤
3B − 1 + rin
a .
The length of the interval [ 2B+rin
b , 3B−1+rin
a ] is
3B − 1 + rin
a − 2B + rin
b ≥
3B − 1 + rin
m0
− 2B + rin
m0
≥
B − 1
m0
≥
1
3
B − 1
B .
Therefore, we can expect to find a pair ri, si that satisfies (2) for about each
third value of ri that is tried. Thus, it seems easy to find such pairs ri, si that
satisfy (1) and (2) just by iterating through possible values for ri.
The probability that si ∈ [
2B+rin
m0 , 3B−1+rin
m0 ] is roughly 1/2. Thus, we will
find a PKCS-conforming si after trying about 2/Pr(P|A) chosen ciphertexts.
Since the remaining interval in Mi is divided in half in each step 2.c, we
expect to find m0 with about
3/Pr(P) + 16k/Pr(P|A)
chosen ciphertexts, where k denotes the size of the modulus in bytes. For Pr(P) =
0.18 · 2−16 and k = 128 (which corresponds to a 1024-bit modulus), we expect
that the attack needs roughly 220 chosen ciphertexts to succeed. The bit length
of the modulus is usually a multiple of 8; hence, Pr(P) is close to 0.18 · 2−16, as
assumed previously.
Remarks. The probabilities in this section were computed under the assumption
that the values si are independent of each other. We made that assumption
to allow a heuristic analysis of the algorithm. However, the assumption may be
wrong in special cases. For example, let us assume that m0 and sim0 are both
PKCS conforming with padding strings of similar length; that is, we have, for
some integer j,
m0 = 2 · 28(k−2) + 28jPS + D
sim0 = 2 · 28(k−2) + 28jPS0 + D0
.
8 Daniel Bleichenbacher
Then, (2si − 1)m0 is PKCS conforming with high probability, since
(2si − 1)m0 = 2 · 28(k−2) + 28j (2PS0 − PS) + 2D0 − D
often is PKCS conforming too. We believe that such relations generally help the
attacker, but it in certain situations the attack might require many more chosen
ciphertexts than our analysis indicates.
Usually, the bit size of the RSA modulus is a multiple of 8. This choice is a
good one, because, for such a modulus, Pr(P) is small. A modulus with a bit
length 8k − 7 would make the attack much easier, because, in that case, only
about 213 chosen messages would be necessary.

** 4 Access to an Oracle
In this section, we describe three situations in which an attacker could get access
to an oracle.

** 4.1 Plain Encryption
Let us assume that a cryptographic protocol starts as follows. Alice generates
a message m (e.g., a randomly chosen key). She encrypts it with PKCS #1,
without applying any further integrity checks, and sends the ciphertext to Bob.
Bob decrypts the message. If the format of the message is not PKCS conforming,
then he returns an error; otherwise, he proceeds according to the protocol.
If Eve impersonates Alice, she can easily send messages to Bob and check
them for conformance. Note that Eve’s attack works even when the protocol
includes strong authentication at a later step, since Eve has obtained useful
information before she has to respond with an authenticated message.
Note that the RSA encryption standard PKCS #1 [11, page 8, note 3] recommends
that a message digest be included before an RSA operation, but for only
the signing procedure. Even though the standard mentions that an encrypted
message does not ensure integrity by itself, the standard does not indicate where
such an integrity check should be included.

** 4.2 Detailed Error Messages
Thus far, we have shown that a reliable integrity check is an important part
of an RSA encryption. One way to include such a check is to let the sender
sign the message with his private key, before he encrypts it with the receiver’s
public key. Then, an attacker can no longer hope to create a correct message by
accident. Her attack will nonetheless be successful when, in the case of a failed
verification, the receiver returns an error message that gives detailed information
about where the verification failed. In particular, it would compromise security
to return different error messages for a message that is not PKCS conforming
and for a message where only the signature verification failed.
Chosen Ciphertext Attacks Against Protocols 9

** 4.3 A Timing Attack
Certain applications combine encryption and signatures. In such cases, a reliable
integrity check often is part of the signature, but is not included in the encryption.
Let us assume that an encrypted message c is decrypted and verified as
shown in the following pseudo-code:
1. Let m ≡ cd (mod n) be the RSA-decryption of c.
2. If m is not PKCS conforming, then reject.
3. Otherwise, verify the signature of m.
4. If the signature is not correct, then reject; otherwise, accept.
An attacker will not be able to generate a chosen ciphertext c such that this
message has a correct signature. However, she will be able to generate messages
such that c sometimes passes the check in step 2 and is rejected only after the
signature is checked. Hence, by measuring the server’s response time, an attacker
could determine whether c is PKCS conforming. This timing attack is much easier
to perform than is Kocher’s timing attack [10], which measures the time
difference of single modular multiplications – a small fraction of the time used
for one exponentiation. In our case, however, we have to distinguish between
performing only an decryption and performing both an decryption and a signature
verification. In the worst case, the time for the signature verification could
be significantly longer than the time for the decryption – when, for example,
we have a 512-bit encryption key because of export restrictions, but we use a
2048-bit key to ensure strong authentication. In addition, the attacker can chose
what signing key is sent to the server.

** 5 SSL V.3.0
00 02 00 premastersecret 03 00
46 bytes
padding string
Fig. 2. SSL block format. Unlike the PKCS format, this format contains the
SSL version number. Moreover, the length of the data block is constant.
The situation discussed in this paper arises in SSL V.3.0 [7] during the handshake
protocol. In particular. the client and server first exchange the messages
client.hello and server.hello, which, among other information exchanges,
select the cryptographic routines. After that, the client and server may send
their public keys and certificates. The client then generates a random secret bit
10 Daniel Bleichenbacher
string called pre master secret, encrypts that secret bit string with RSA (if
that mode was chosen earlier), and sends the resulting ciphertext to the server.
The server decrypts the ciphertext. If the plaintext is not PKCS conforming,
the server sends an alert message to the client and closes the connection; otherwise,
the server continues the handshake protocol. Finally, the client has to
send a finished message, which contains strong authentication. In particular,
the client has to know the pre master secret to compute that message.
Because an attacker must generate a finished message that depends on the
pre master secret, she cannot complete the handshake protocol successfully.
However, she does not have to complete it; she gets the necessary information –
namely, whether her chosen message is PKCS conforming – before the protocol
is finished.
There are details of SSL V.3.0 that might hinder this attack if they are
implemented the right way. Figure 2 shows the format of the message containing
the pre master secret before the latter is encrypted with RSA. It contains
the version number of the protocol, the purpose of which is to detect versionrollback
attacks, in which an attacker tries to modify the hello messages such
that both client and server use the compatibility mode and hence use the Version
2.0, instead of Version 3.0, protocols. One implementation that we analyzed [12]
checks the version number only if the server is running in the compatibility mode,
because otherwise obviously no rollback attack has occurred.
A much more secure implementation would check the version number in all
modes, and, if it identified a mismatch, would send back to the client the same
error alert as it sends in the case of a decryption error. The result would be that
a randomly generated message would be accepted with a probability of about
2−40; although such a protocol still could not be called secure, the attack shown
in this paper would at least be impractical.
The SSL documentation does not specify clearly the error conditions and
corresponding alerts. As a result, different implementations of SSL do not react
consistently with one another in error situations.

** 6 Experimental Results
We implemented the algorithm described in Section 3 and verified experimentally
that this algorithm can decrypt a PKCS #1 encrypted message given access
to an oracle that, for any ciphertext, indicates whether the the corresponding
plaintext is PKCS conforming. We tested the algorithm with different 512-bit
and 1024-bit keys. The algorithm needed between 300 thousand and 2 million
chosen ciphertexts to find the message. We implemented our own version of the
oracle, rather than using an existing software product.
Finney checked three different SSL servers [6] to find out how carefully the
servers analyze the message format and what error alerts are returned. One of
the servers verified only the PKCS format. The second server checked the PKCS
format, message length, and version number, but returned different message
Chosen Ciphertext Attacks Against Protocols 11
alerts, thus still allowing our attack. Only the third server checked all aspects
correctly and did not leak information by sending different alerts.

** 7 Conclusion
We have shown a chosen-ciphertext attack that can be carried out when only partial
information about the corresponding message is leaked. We conclude not only
that it is important to include a strong integrity check into an RSA encryption,
but also that this integrity check must be performed in the correct step of the
protocol – preferably immediately after decryption. The phase between decryption
and integrity check is critical, because even sending out error messages can
present a security risk. We also believe that we have provided a strong argument
to use plaintext-aware encryption schemes, such as the one described by Bellare
and Rogaway [3]. Note that plaintext awareness implies security against chosenciphertext
attacks [2,3]. In particular, Version 2 of PKCS #1, which makes use
of [3], is not susceptible to the attack described in this paper.
It is a good idea to have a receiver check the integrity of a message immediately
after decrypting that message. Even better is to check integrity before
decrypting a message, as Cramer and Shoup show is possible [4].

** Acknowledgments
I thank Markus Jakobsson, David M. Kristol, and Jean-Fran¸cois Misarsky, as
well as the members of the program committee, for all their comments and
suggestions. I am grateful for the cooperation of the people at RSA Laboratories.
I thank Hal Finney for telling me about his experiments on different SSL servers.
I am also grateful to Lyn Dupr´e for editing this paper.
References
1. W. Alexi, B. Chor, O. Goldreich, and P. Schnorr. Bit security of RSA and Rabin
functions. SIAM Journal of computing, 17(2):194–209, Apr. 1988. 3
2. M. Bellare, A. Desai, D. Pointcheval, and P. Rogaway. Relations among notions of
security for public-key encryptions schemes. In H. Krawczyk, editor, Advances in
Cryptology – CRYPTO ’98, Lecture Notes in Computer Science. Springer Verlag.
(in press). 11
3. M. Bellare and P. Rogaway. Optimal asymmetric encryption. In A. D. Santis,
editor, Advances in Cryptology – EUROCRYPT ’94, volume 950 of Lecture Notes
in Computer Science, pages 92–111, Berlin, 1995. Springer Verlag. 11, 11, 11
4. R. Cramer and V. Shoup. A practical public key cryptosystem provably secure
against adaptive chosen ciphertext attack. In H. Krawczyk, editor, Advances in
Cryptology – CRYPTO ’98, Lecture Notes in Computer Science. Springer Verlag.
(in press). 11
5. G. I. Davida. Chosen signature cryptanalysis of the RSA (MIT) public key cryptosystem.
Technical Report TR-CS-82-2, Departement of Electrical Engineering
and Computer Science, University of Wisconsin, Milwaukee, 1982. 3
12 Daniel Bleichenbacher
6. H. Finney. personal communication. 10
7. A. O. Freier, P. Karlton, and P. C. Kocher. The SSL Protocol, Version 3.0.
Netscape, Mountain View, CA, 96. 9
8. S. Goldwasser, S. Micali, and P. Tong. Why and how to establish a private code
on a public network. In Proc. 23rd IEEE Symp. on Foundations of Comp. Science,
pages 134–144, Chicago, 1982. 3
9. J. H˚astad and M. N¨aslund. The security of individual RSA bits. manusrcipt, 1998.
3, 3
10. P. C. Kocher. Timing attacks on implementations of Diffie–Hellman RSA, DSS,
and other systems. In N. Koblitz, editor, Advances in Cryptology – CRYPTO ’96,
volume 1109 of Lecture Notes in Computer Science, pages 104–113, Berlin, 1996.
Springer Verlag. 9
11. RSA Data Security, Inc. PKCS #1: RSA Encryption Standard. Redwood City,
CA, Nov. 1993. Version 1.5. 2, 8
12. E. A. Young. SSLeay 0.8.1. url = http://www.cryptsoft.com/ 10


* Bleichenbacher's RSA signature forgery based on implementation
--------------------------------------------------------------------------

From: hal at finney.org ("Hal Finney") 
To: ietf-openpgp at imc.org 
Date: Sun, 27 Aug 2006 22:42:46 -0700 (PDT) 

--------------------------------------------------------------------------
At the evening rump session at Crypto last week, Daniel Bleichenbacher
gave a talk showing how it is possible under some circumstances to
easily forge an RSA signature, so easily that it could almost be done
with just pencil and paper.  This depends on an implementation error,
a failure to check a certain condition while verifying the RSA signature.
Daniel found at least one implementation (I think it was some Java crypto
code, not OpenPGP related) which had this flaw.  I wanted to report on
his result here so that other OpenPGP implementers can make sure they
are not vulnerable.  Be aware that my notes were hurried as Daniel had
only a few minutes to talk.

The attack is only good against keys with exponent of 3.  There are
not too many of these around any more but you still run into them
occasionally.  It depends on an error in verifying the PKCS-1 padding
of the signed hash.

An RSA signature is created in several steps.  First the data to be
signed is hashed.  Then the hash gets a special string of bytes in ASN.1
format prepended, which indicates what hash algorithm is used.  This data
is then PKCS-1 padded to be the width of the RSA modulus.  The PKCS-1
padding consists of a byte of 0, then 1, then a string of 0xFF bytes,
then a byte of zero, then the "payload" which is the hash+ASN.1 data.
Graphically:

00 01 FF FF FF ... FF 00  ASN.1  HASH

The signature verifier first applies the RSA public exponent to reveal
this PKCS-1 padded data, checks and removes the PKCS-1 padding, then
compares the hash with its own hash value computed over the signed data.

The error that Bleichenbacher exploits is if the implementation does
not check that the hash+ASN.1 data is right-justified within the PKCS-1
padding.  Some implementations apparently remove the PKCS-1 padding by
looking for the high bytes of 0 and 1, then the 0xFF bytes, then
the zero byte; and then they start parsing the ASN.1 data and hash.
The ASN.1 data encodes the length of the hash within it, so this tells
them how big the hash value is.  These broken implementations go ahead
and use the hash, without verifying that there is no more data after it.
Failing to add this extra check makes implementations vulnerable to a
signature forgery, as follows.

Daniel forges the RSA signature for an exponent of 3 by constructing a
value which is a perfect cube.  Then he can use its cube root as the
RSA signature.  He starts by putting the ASN.1+hash in the middle of
the data field instead of at the right side as it should be.  Graphically:

00 01 FF FF ... FF 00  ASN.1  HASH  GARBAGE

This gives him complete freedom to put anything he wants to the right
of the hash.  This gives him enough flexibility that he can arrange for
the value to be a perfect cube.

In more detail, let D represent the numeric value of the 00 byte, the
ASN.1 data, and the hash, considered as a byte string.  In the case
of SHA-1 this will be 36 bytes or 288 bits long.  Define N as 2^288-D.
We will assume that N is a multiple of 3, which can easily be arranged
by slightly tweaking the message if neccessary.

Bleichenbacher uses an example of a 3072 bit key, and he will position
the hash 2072 bits over from the right.  This improperly padded version
can be expressed numerically as 2^3057 - 2^2360 + D * 2^2072 + garbage.
This is equivalent to 2^3057 - N*2^2072 + garbage.  Then, it turns out
that a cube root of this is simply 2^1019 - (N * 2^34 / 3), and that is
a value which broken implementations accept as an RSA signature.

You can cube this mentally, remembering that the cube of (A-B) is A^3 -
3(A^2)B + 3A(B^2) - B^3.  Applying that rule gives 2^3057 - N*2^2072
+ (N^2 * 2^1087 / 3) - (N^3 * 2^102 / 27), and this fits the pattern
above of 2^3057 - N*2^2072 + garbage.  This is what Daniel means when
he says that this attack is simple enough that it could be carried out
by pencil and paper (except for the hash calculation itself).

Implementors should review their RSA signature verification carefully to
make sure that they are not being sloppy here.  Remember the maxim that in
cryptography, verification checks should err on the side of thoroughness.
This is no place for laxity or permissiveness.

Daniel also recommends that people stop using RSA keys with exponents
of 3.  Even if your own implementation is not vulnerable to this attack,
there's no telling what the other guy's code may do.  And he is the one
relying on your signature.

Hal Finney


--------------------------------------------------------------------------

Prev by Date: Multisig (was: OpenPGP Minutes / Quick Summary) 
Next by Date: keys for regression testing of OpenPGP code 
Previous by thread: Re: OpenPGP Minutes / Quick Summary 
Next by thread: keys for regression testing of OpenPGP code 



* PKCS#1 Padding v1.5
  
** Intro
Obsoleted by: 2437                                         INFORMATIONAL
                                                                        
Network Working Group                                      B. Kaliski
Request for Comments: 2313                      RSA Laboratories East
Category: Informational                                    March 1998


                        PKCS #1: RSA Encryption
                              Version 1.5

Status of this Memo

   This memo provides information for the Internet community.  It does
   not specify an Internet standard of any kind.  Distribution of this
   memo is unlimited.

Copyright Notice

   Copyright (C) The Internet Society (1998).  All Rights Reserved.

Overview

   This document describes a method for encrypting data using the RSA
   public-key cryptosystem.

** 1. Scope

   This document describes a method for encrypting data using the RSA
   public-key cryptosystem. Its intended use is in the construction of
   digital signatures and digital envelopes, as described in PKCS #7:

        o    For digital signatures, the content to be signed
             is first reduced to a message digest with a
             message-digest algorithm (such as MD5), and then
             an octet string containing the message digest is
             encrypted with the RSA private key of the signer
             of the content. The content and the encrypted
             message digest are represented together according
             to the syntax in PKCS #7 to yield a digital
             signature. This application is compatible with
             Privacy-Enhanced Mail (PEM) methods.

        o    For digital envelopes, the content to be enveloped
             is first encrypted under a content-encryption key
             with a content-encryption algorithm (such as DES),
             and then the content-encryption key is encrypted
             with the RSA public keys of the recipients of the
             content. The encrypted content and the encrypted





Kaliski                      Informational                      [Page 1]
 
RFC 2313                PKCS #1: RSA Encryption               March 1998


             content-encryption key are represented together
             according to the syntax in PKCS #7 to yield a
             digital envelope. This application is also
             compatible with PEM methods.

   The document also describes a syntax for RSA public keys and private
   keys. The public-key syntax would be used in certificates; the
   private-key syntax would be used typically in PKCS #8 private-key
   information. The public-key syntax is identical to that in both X.509
   and Privacy-Enhanced Mail.  Thus X.509/PEM RSA keys can be used in
   this document.

   The document also defines three signature algorithms for use in
   signing X.509/PEM certificates and certificate-revocation lists, PKCS
   #6 extended certificates, and other objects employing digital
   signatures such as X.401 message tokens.

   Details on message-digest and content-encryption algorithms are
   outside the scope of this document, as are details on sources of the
   pseudorandom bits required by certain methods in this document.

** 2. References

   FIPS PUB 46-1  National Bureau of Standards. FIPS PUB 46-1:
             Data Encryption Standard. January 1988.

   PKCS #6   RSA Laboratories. PKCS #6: Extended-Certificate
             Syntax. Version 1.5, November 1993.

   PKCS #7   RSA Laboratories. PKCS #7: Cryptographic Message
             Syntax. Version 1.5, November 1993.

   PKCS #8   RSA Laboratories. PKCS #8: Private-Key Information
             Syntax. Version 1.2, November 1993.

   RFC 1319  Kaliski, B., "The MD2 Message-Digest
             Algorithm," RFC 1319, April 1992.

   RFC 1320  Rivest, R., "The MD4 Message-Digest
             Algorithm," RFC 1320, April 1992.

   RFC 1321  Rivest, R., "The MD5 Message-Digest
             Algorithm," RFC 1321, April 1992.

   RFC 1423  Balenson, D., "Privacy Enhancement for
             Internet Electronic Mail: Part III: Algorithms,
             Modes, and Identifiers," RFC 1423, February 1993.




Kaliski                      Informational                      [Page 2]
 
RFC 2313                PKCS #1: RSA Encryption               March 1998


   X.208     CCITT. Recommendation X.208: Specification of
             Abstract Syntax Notation One (ASN.1). 1988.

   X.209     CCITT. Recommendation X.209: Specification of
             Basic Encoding Rules for Abstract Syntax Notation
             One (ASN.1). 1988.

   X.411     CCITT. Recommendation X.411: Message Handling
             Systems: Message Transfer System: Abstract Service
             Definition and Procedures.1988.

   X.509     CCITT. Recommendation X.509: The Directory--
             Authentication Framework. 1988.

   [dBB92]   B. den Boer and A. Bosselaers. An attack on the
             last two rounds of MD4. In J. Feigenbaum, editor,
             Advances in Cryptology---CRYPTO '91 Proceedings,
             volume 576 of Lecture Notes in Computer Science,
             pages 194-203. Springer-Verlag, New York, 1992.

   [dBB93]   B. den Boer  and A. Bosselaers. Collisions for the
             compression function of MD5. Presented at
             EUROCRYPT '93 (Lofthus, Norway, May 24-27, 1993).

   [DO86]    Y. Desmedt and A.M. Odlyzko. A chosen text attack
             on the RSA cryptosystem and some discrete
             logarithm schemes. In H.C. Williams, editor,
             Advances in Cryptology---CRYPTO '85 Proceedings,
             volume 218 of Lecture Notes in Computer Science,
             pages 516-521. Springer-Verlag, New York, 1986.

   [Has88]   Johan Hastad. Solving simultaneous modular
             equations. SIAM Journal on Computing,
             17(2):336-341, April 1988.

   [IM90]    Colin I'Anson and Chris Mitchell. Security defects
             in CCITT Recommendation X.509--The directory
             authentication framework. Computer Communications
             Review, :30-34, April 1990.

   [Mer90]   R.C. Merkle. Note on MD4. Unpublished manuscript,
             1990.

   [Mil76]   G.L. Miller. Riemann's hypothesis and tests for
             primality. Journal of Computer and Systems
             Sciences, 13(3):300-307, 1976.





Kaliski                      Informational                      [Page 3]
 
RFC 2313                PKCS #1: RSA Encryption               March 1998


   [QC82]    J.-J. Quisquater and C. Couvreur. Fast
             decipherment algorithm for RSA public-key
             cryptosystem. Electronics Letters, 18(21):905-907,
             October 1982.

   [RSA78]   R.L. Rivest, A. Shamir, and L. Adleman. A method
             for obtaining digital signatures and public-key
             cryptosystems. Communications of the ACM,
             21(2):120-126, February 1978.

** 3. Definitions

   For the purposes of this document, the following definitions apply.

   AlgorithmIdentifier: A type that identifies an algorithm (by object
   identifier) and associated parameters. This type is defined in X.509.

   ASN.1: Abstract Syntax Notation One, as defined in X.208.

   BER: Basic Encoding Rules, as defined in X.209.

   DES: Data Encryption Standard, as defined in FIPS PUB 46-1.

   MD2: RSA Data Security, Inc.'s MD2 message-digest algorithm, as
   defined in RFC 1319.

   MD4: RSA Data Security, Inc.'s MD4 message-digest algorithm, as
   defined in RFC 1320.

   MD5: RSA Data Security, Inc.'s MD5 message-digest algorithm, as
   defined in RFC 1321.

   modulus: Integer constructed as the product of two primes.

   PEM: Internet Privacy-Enhanced Mail, as defined in RFC 1423 and
   related documents.

   RSA: The RSA public-key cryptosystem, as defined in [RSA78].

   private key: Modulus and private exponent.

   public key: Modulus and public exponent.

** 4. Symbols and abbreviations

   Upper-case symbols (e.g., BT) denote octet strings and bit strings
   (in the case of the signature S); lower-case symbols (e.g., c) denote
   integers.



Kaliski                      Informational                      [Page 4]
 
RFC 2313                PKCS #1: RSA Encryption               March 1998


   ab   hexadecimal octet value  c    exponent
   BT   block type               d    private exponent
   D    data                     e    public exponent
   EB   encryption block         k    length of modulus in
                                        octets
   ED   encrypted data           n    modulus
   M    message                  p, q  prime factors of modulus
   MD   message digest           x    integer encryption block
   MD'  comparative message      y    integer encrypted data
          digest
   PS   padding string           mod n  modulo n
   S    signature                X || Y  concatenation of X, Y
                                ||X||  length in octets of X
** 5. General overview

   The next six sections specify key generation, key syntax, the
   encryption process, the decryption process, signature algorithms, and
   object identifiers.

   Each entity shall generate a pair of keys: a public key and a private
   key. The encryption process shall be performed with one of the keys
   and the decryption process shall be performed with the other key.
   Thus the encryption process can be either a public-key operation or a
   private-key operation, and so can the decryption process. Both
   processes transform an octet string to another octet string. The
   processes are inverses of each other if one process uses an entity's
   public key and the other process uses the same entity's private key.

   The encryption and decryption processes can implement either the
   classic RSA transformations, or variations with padding.

** 6. Key generation

   This section describes RSA key generation.

   Each entity shall select a positive integer e as its public exponent.

   Each entity shall privately and randomly select two distinct odd
   primes p and q such that (p-1) and e have no common divisors, and
   (q-1) and e have no common divisors.

   The public modulus n shall be the product of the private prime
   factors p and q:

                                 n = pq .

   The private exponent shall be a positive integer d such that de-1 is
   divisible by both p-1 and q-1.



Kaliski                      Informational                      [Page 5]
 
RFC 2313                PKCS #1: RSA Encryption               March 1998


   The length of the modulus n in octets is the integer k satisfying

                        2^(8(k-1)) <= n < 2^(8k) .

   The length k of the modulus must be at least 12 octets to accommodate
   the block formats in this document (see Section 8).

   Notes.

        1.   The public exponent may be standardized in
             specific applications. The values 3 and F4 (65537) may have
             some practical advantages, as noted in X.509 Annex C.

        2.   Some additional conditions on the choice of primes
             may well be taken into account in order to deter
             factorization of the modulus. These security conditions
             fall outside the scope of this document. The lower bound on
             the length k is to accommodate the block formats, not for
             security.

** 7. Key syntax

   This section gives the syntax for RSA public and private keys.

7.1 Public-key syntax

   An RSA public key shall have ASN.1 type RSAPublicKey:

   RSAPublicKey ::= SEQUENCE {
     modulus INTEGER, -- n
     publicExponent INTEGER -- e }

   (This type is specified in X.509 and is retained here for
   compatibility.)

   The fields of type RSAPublicKey have the following meanings:

        o    modulus is the modulus n.

        o    publicExponent is the public exponent e.











Kaliski                      Informational                      [Page 6]
 
RFC 2313                PKCS #1: RSA Encryption               March 1998


7.2 Private-key syntax

   An RSA private key shall have ASN.1 type RSAPrivateKey:

   RSAPrivateKey ::= SEQUENCE {
     version Version,
     modulus INTEGER, -- n
     publicExponent INTEGER, -- e
     privateExponent INTEGER, -- d
     prime1 INTEGER, -- p
     prime2 INTEGER, -- q
     exponent1 INTEGER, -- d mod (p-1)
     exponent2 INTEGER, -- d mod (q-1)
     coefficient INTEGER -- (inverse of q) mod p }

   Version ::= INTEGER

   The fields of type RSAPrivateKey have the following meanings:

        o    version is the version number, for compatibility
             with future revisions of this document. It shall
             be 0 for this version of the document.

        o    modulus is the modulus n.

        o    publicExponent is the public exponent e.

        o    privateExponent is the private exponent d.

        o    prime1 is the prime factor p of n.

        o    prime2 is the prime factor q of n.

        o    exponent1 is d mod (p-1).

        o    exponent2 is d mod (q-1).

        o    coefficient is the Chinese Remainder Theorem
             coefficient q-1 mod p.

   Notes.

        1.   An RSA private key logically consists of only the
             modulus n and the private exponent d. The presence of the
             values p, q, d mod (p-1), d mod (p-1), and q-1 mod p is
             intended for efficiency, as Quisquater and Couvreur have
             shown [QC82]. A private-key syntax that does not include




Kaliski                      Informational                      [Page 7]
 
RFC 2313                PKCS #1: RSA Encryption               March 1998


             all the extra values can be converted readily to the syntax
             defined here, provided the public key is known, according
             to a result by Miller [Mil76].

        2.   The presence of the public exponent e is intended
             to make it straightforward to derive a public key from the
             private key.

** 8. Encryption process

   This section describes the RSA encryption process.

   The encryption process consists of four steps: encryption- block
   formatting, octet-string-to-integer conversion, RSA computation, and
   integer-to-octet-string conversion. The input to the encryption
   process shall be an octet string D, the data; an integer n, the
   modulus; and an integer c, the exponent. For a public-key operation,
   the integer c shall be an entity's public exponent e; for a private-
   key operation, it shall be an entity's private exponent d. The output
   from the encryption process shall be an octet string ED, the
   encrypted data.

   The length of the data D shall not be more than k-11 octets, which is
   positive since the length k of the modulus is at least 12 octets.
   This limitation guarantees that the length of the padding string PS
   is at least eight octets, which is a security condition.

   Notes.

        1.   In typical applications of this document to
             encrypt content-encryption keys and message digests, one
             would have ||D|| <= 30. Thus the length of the RSA modulus
             will need to be at least 328 bits (41 octets), which is
             reasonable and consistent with security recommendations.

        2.   The encryption process does not provide an
             explicit integrity check to facilitate error detection
             should the encrypted data be corrupted in transmission.
             However, the structure of the encryption block guarantees
             that the probability that corruption is undetected is less
             than 2-16, which is an upper bound on the probability that
             a random encryption block looks like block type 02.

        3.   Application of private-key operations as defined
             here to data other than an octet string containing a
             message digest is not recommended and is subject to further
             study.




Kaliski                      Informational                      [Page 8]
 
RFC 2313                PKCS #1: RSA Encryption               March 1998


        4.   This document may be extended to handle data of
             length more than k-11 octets.

8.1 Encryption-block formatting

   A block type BT, a padding string PS, and the data D shall be
   formatted into an octet string EB, the encryption block.

              EB = 00 || BT || PS || 00 || D .           (1)

   The block type BT shall be a single octet indicating the structure of
   the encryption block. For this version of the document it shall have
   value 00, 01, or 02. For a private- key operation, the block type
   shall be 00 or 01. For a public-key operation, it shall be 02.

   The padding string PS shall consist of k-3-||D|| octets. For block
   type 00, the octets shall have value 00; for block type 01, they
   shall have value FF; and for block type 02, they shall be
   pseudorandomly generated and nonzero. This makes the length of the
   encryption block EB equal to k.

   Notes.

        1.   The leading 00 octet ensures that the encryption
             block, converted to an integer, is less than the modulus.

        2.   For block type 00, the data D must begin with a
             nonzero octet or have known length so that the encryption
             block can be parsed unambiguously. For block types 01 and
             02, the encryption block can be parsed unambiguously since
             the padding string PS contains no octets with value 00 and
             the padding string is separated from the data D by an octet
             with value 00.

        3.   Block type 01 is recommended for private-key
             operations. Block type 01 has the property that the
             encryption block, converted to an integer, is guaranteed to
             be large, which prevents certain attacks of the kind
             proposed by Desmedt and Odlyzko [DO86].

        4.   Block types 01 and 02 are compatible with PEM RSA
             encryption of content-encryption keys and message digests
             as described in RFC 1423.








Kaliski                      Informational                      [Page 9]
 
RFC 2313                PKCS #1: RSA Encryption               March 1998


        5.   For block type 02, it is recommended that the
             pseudorandom octets be generated independently for each
             encryption process, especially if the same data is input to
             more than one encryption process.  Hastad's results [Has88]
             motivate this recommendation.

        6.   For block type 02, the padding string is at least
             eight octets long, which is a security condition for
             public-key operations that prevents an attacker from
             recoving data by trying all possible encryption blocks. For
             simplicity, the minimum length is the same for block type
             01.

        7.   This document may be extended in the future to
             include other block types.

8.2 Octet-string-to-integer conversion

   The encryption block EB shall be converted to an integer x, the
   integer encryption block. Let EB1, ..., EBk be the octets of EB from
   first to last. Then the integer x shall satisfy

                                     k
                x =  SUM  2^(8(k-i)) EBi .              (2)
                                   i = 1

   In other words, the first octet of EB has the most significance in
   the integer and the last octet of EB has the least significance.

   Note. The integer encryption block x satisfies 0 <= x <  n since EB1
   = 00 and 2^(8(k-1)) <= n.

8.3 RSA computation

   The integer encryption block x shall be raised to the power c modulo
   n to give an integer y, the integer encrypted data.

                       y = x^c mod n,  0 <= y < n .

   This is the classic RSA computation.

8.4 Integer-to-octet-string conversion

   The integer encrypted data y shall be converted to an octet string ED
   of length k, the encrypted data. The encrypted data ED shall satisfy






Kaliski                      Informational                     [Page 10]
 
RFC 2313                PKCS #1: RSA Encryption               March 1998


                                     k
                y =  SUM  2^(8(k-i)) EDi .              (3)
                                   i = 1

   where ED1, ..., EDk are the octets of ED from first to last.

   In other words, the first octet of ED has the most significance in
   the integer and the last octet of ED has the least significance.

** 9. Decryption process

   This section describes the RSA decryption process.

   The decryption process consists of four steps: octet-string-to-
   integer conversion, RSA computation, integer-to-octet-string
   conversion, and encryption-block parsing. The input to the decryption
   process shall be an octet string ED, the encrypted data; an integer
   n, the modulus; and an integer c, the exponent. For a public-key
   operation, the integer c shall be an entity's public exponent e; for
   a private-key operation, it shall be an entity's private exponent d.
   The output from the decryption process shall be an octet string D,
   the data.

   It is an error if the length of the encrypted data ED is not k.

   For brevity, the decryption process is described in terms of the
   encryption process.

9.1 Octet-string-to-integer conversion

   The encrypted data ED shall be converted to an integer y, the integer
   encrypted data, according to Equation (3).

   It is an error if the integer encrypted data y does not satisfy 0 <=
   y < n.

9.2 RSA computation

   The integer encrypted data y shall be raised to the power c modulo n
   to give an integer x, the integer encryption block.

                       x = y^c mod n,  0 <= x < n .

   This is the classic RSA computation.







Kaliski                      Informational                     [Page 11]
 
RFC 2313                PKCS #1: RSA Encryption               March 1998


9.3 Integer-to-octet-string conversion

   The integer encryption block x shall be converted to an octet string
   EB of length k, the encryption block, according to Equation (2).

9.4 Encryption-block parsing

   The encryption block EB shall be parsed into a block type BT, a
   padding string PS, and the data D according to Equation (1).

   It is an error if any of the following conditions occurs:

        o    The encryption block EB cannot be parsed
             unambiguously (see notes to Section 8.1).

        o    The padding string PS consists of fewer than eight
             octets, or is inconsistent with the block type BT.

        o    The decryption process is a public-key operation
             and the block type BT is not 00 or 01, or the decryption
             process is a private-key operation and the block type is
             not 02.

** 10. Signature algorithms

   This section defines three signature algorithms based on the RSA
   encryption process described in Sections 8 and 9. The intended use of
   the signature algorithms is in signing X.509/PEM certificates and
   certificate-revocation lists, PKCS #6 extended certificates, and
   other objects employing digital signatures such as X.401 message
   tokens. The algorithms are not intended for use in constructing
   digital signatures in PKCS #7. The first signature algorithm
   (informally, "MD2 with RSA") combines the MD2 message-digest
   algorithm with RSA, the second (informally, "MD4 with RSA") combines
   the MD4 message-digest algorithm with RSA, and the third (informally,
   "MD5 with RSA") combines the MD5 message-digest algorithm with RSA.

   This section describes the signature process and the verification
   process for the two algorithms. The "selected" message-digest
   algorithm shall be either MD2 or MD5, depending on the signature
   algorithm. The signature process shall be performed with an entity's
   private key and the verification process shall be performed with an
   entity's public key. The signature process transforms an octet string
   (the message) to a bit string (the signature); the verification
   process determines whether a bit string (the signature) is the
   signature of an octet string (the message).





Kaliski                      Informational                     [Page 12]
 
RFC 2313                PKCS #1: RSA Encryption               March 1998


   Note. The only difference between the signature algorithms defined
   here and one of the the methods by which signatures (encrypted
   message digests) are constructed in PKCS #7 is that signatures here
   are represented here as bit strings, for consistency with the X.509
   SIGNED macro. In PKCS #7 encrypted message digests are octet strings.

10.1 Signature process

   The signature process consists of four steps: message digesting, data
   encoding, RSA encryption, and octet-string-to-bit-string conversion.
   The input to the signature process shall be an octet string M, the
   message; and a signer's private key. The output from the signature
   process shall be a bit string S, the signature.

10.1.1 Message digesting

   The message M shall be digested with the selected message- digest
   algorithm to give an octet string MD, the message digest.

10.1.2 Data encoding

   The message digest MD and a message-digest algorithm identifier shall
   be combined into an ASN.1 value of type DigestInfo, described below,
   which shall be BER-encoded to give an octet string D, the data.

   DigestInfo ::= SEQUENCE {
     digestAlgorithm DigestAlgorithmIdentifier,
     digest Digest }

   DigestAlgorithmIdentifier ::= AlgorithmIdentifier

   Digest ::= OCTET STRING

   The fields of type DigestInfo have the following meanings:

        o    digestAlgorithm identifies the message-digest
             algorithm (and any associated parameters). For
             this application, it should identify the selected
             message-digest algorithm, MD2, MD4 or MD5. For
             reference, the relevant object identifiers are the
             following:










Kaliski                      Informational                     [Page 13]
 
RFC 2313                PKCS #1: RSA Encryption               March 1998


   md2 OBJECT IDENTIFIER ::=

     { iso(1) member-body(2) US(840) rsadsi(113549)
         digestAlgorithm(2) 2 } md4 OBJECT IDENTIFIER ::=
     { iso(1) member-body(2) US(840) rsadsi(113549)
         digestAlgorithm(2) 4 } md5 OBJECT IDENTIFIER ::=
     { iso(1) member-body(2) US(840) rsadsi(113549)
         digestAlgorithm(2) 5 }

             For these object identifiers, the parameters field of the
             digestAlgorithm value should be NULL.

        o    digest is the result of the message-digesting
             process, i.e., the message digest MD.

   Notes.

        1.   A message-digest algorithm identifier is included
             in the DigestInfo value to limit the damage resulting from
             the compromise of one message-digest algorithm. For
             instance, suppose an adversary were able to find messages
             with a given MD2 message digest.  That adversary might try
             to forge a signature on a message by finding an innocuous-
             looking message with the same MD2 message digest, and
             coercing a signer to sign the innocuous-looking message.
             This attack would succeed only if the signer used MD2. If
             the DigestInfo value contained only the message digest,
             however, an adversary could attack signers that use any
             message digest.

        2.   Although it may be claimed that the use of a
             SEQUENCE type violates the literal statement in the X.509
             SIGNED and SIGNATURE macros that a signature is an
             ENCRYPTED OCTET STRING (as opposed to ENCRYPTED SEQUENCE),
             such a literal interpretation need not be required, as
             I'Anson and Mitchell point out [IM90].

        3.  No reason is known that MD4 would not be
             for very high security digital signature schemes, but
             because MD4 was designed to be exceptionally fast, it is
             "at the edge" in terms of risking successful cryptanalytic
             attack.  A message-digest algorithm can be considered
             "broken" if someone can find a collision: two messages with
             the same digest. While collisions have been found in
             variants of MD4 with only two digesting "rounds"






Kaliski                      Informational                     [Page 14]
 
RFC 2313                PKCS #1: RSA Encryption               March 1998


             [Mer90][dBB92], none have been found in MD4 itself, which
             has three rounds. After further critical review, it may be
             appropriate to consider MD4 for very high security
             applications.

             MD5, which has four rounds and is proportionally slower
             than MD4, is recommended until the completion of MD4's
             review. The reported "pseudocollisions" in MD5's internal
             compression function [dBB93] do not appear to have any
             practical impact on  MD5's security.

             MD2, the slowest of the three, has the most conservative
             design. No attacks on MD2 have been published.

10.1.3 RSA encryption

   The data D shall be encrypted with the signer's RSA private key as
   described in Section 7 to give an octet string ED, the encrypted
   data. The block type shall be 01. (See Section 8.1.)

10.1.4 Octet-string-to-bit-string conversion

   The encrypted data ED shall be converted into a bit string S, the
   signature. Specifically, the most significant bit of the first octet
   of the encrypted data shall become the first bit of the signature,
   and so on through the least significant bit of the last octet of the
   encrypted data, which shall become the last bit of the signature.

   Note. The length in bits of the signature S is a multiple of eight.

10.2 Verification process

   The verification process for both signature algorithms consists of
   four steps: bit-string-to-octet-string conversion, RSA decryption,
   data decoding, and message digesting and comparison. The input to the
   verification process shall be an octet string M, the message; a
   signer's public key; and a bit string S, the signature. The output
   from the verification process shall be an indication of success or
   failure.

10.2.1 Bit-string-to-octet-string conversion

   The signature S shall be converted into an octet string ED, the
   encrypted data. Specifically, assuming that the length in bits of the
   signature S is a multiple of eight, the first bit of the signature
   shall become the most significant bit of the first octet of the





Kaliski                      Informational                     [Page 15]
 
RFC 2313                PKCS #1: RSA Encryption               March 1998


   encrypted data, and so on through the last bit of the signature,
   which shall become the least significant bit of the last octet of the
   encrypted data.

   It is an error if the length in bits of the signature S is not a
   multiple of eight.

10.2.2 RSA decryption

   The encrypted data ED shall be decrypted with the signer's RSA public
   key as described in Section 8 to give an octet string D, the data.

   It is an error if the block type recovered in the decryption process
   is not 01. (See Section 9.4.)

10.2.3 Data decoding

   The data D shall be BER-decoded to give an ASN.1 value of type
   DigestInfo, which shall be separated into a message digest MD and a
   message-digest algorithm identifier. The message-digest algorithm
   identifier shall determine the "selected" message-digest algorithm
   for the next step.

   It is an error if the message-digest algorithm identifier does not
   identify the MD2, MD4 or MD5 message-digest algorithm.

10.2.4 Message digesting and comparison

   The message M shall be digested with the selected message-digest
   algorithm to give an octet string MD', the comparative message
   digest. The verification process shall succeed if the comparative
   message digest MD' is the same as the message digest MD, and the
   verification process shall fail otherwise.

** 11. Object identifiers

   This document defines five object identifiers: pkcs-1, rsaEncryption,
   md2WithRSAEncryption, md4WithRSAEncryption, and md5WithRSAEncryption.

   The object identifier pkcs-1 identifies this document.

   pkcs-1 OBJECT IDENTIFIER ::=

     { iso(1) member-body(2) US(840) rsadsi(113549)
         pkcs(1) 1 }






Kaliski                      Informational                     [Page 16]
 
RFC 2313                PKCS #1: RSA Encryption               March 1998


   The object identifier rsaEncryption identifies RSA public and private
   keys as defined in Section 7 and the RSA encryption and decryption
   processes defined in Sections 8 and 9.

   rsaEncryption OBJECT IDENTIFIER ::= { pkcs-1 1 }

   The rsaEncryption object identifier is intended to be used in the
   algorithm field of a value of type AlgorithmIdentifier. The
   parameters field of that type, which has the algorithm-specific
   syntax ANY DEFINED BY algorithm, would have ASN.1 type NULL for this
   algorithm.

   The object identifiers md2WithRSAEncryption, md4WithRSAEncryption,
   md5WithRSAEncryption, identify, respectively, the "MD2 with RSA,"
   "MD4 with RSA," and "MD5 with RSA" signature and verification
   processes defined in Section 10.

   md2WithRSAEncryption OBJECT IDENTIFIER ::= { pkcs-1 2 }
   md4WithRSAEncryption OBJECT IDENTIFIER ::= { pkcs-1 3 }
   md5WithRSAEncryption OBJECT IDENTIFIER ::= { pkcs-1 4 }

   These object identifiers are intended to be used in the algorithm
   field of a value of type AlgorithmIdentifier. The parameters field of
   that type, which has the algorithm-specific syntax ANY DEFINED BY
   algorithm, would have ASN.1 type NULL for these algorithms.

   Note. X.509's object identifier rsa also identifies RSA public keys
   as defined in Section 7, but does not identify private keys, and
   identifies different encryption and decryption processes. It is
   expected that some applications will identify public keys by rsa.
   Such public keys are compatible with this document; an rsaEncryption
   process under an rsa public key is the same as the rsaEncryption
   process under an rsaEncryption public key.

Security Considerations

   Security issues are discussed throughout this memo.

Revision history

   Versions 1.0-1.3

   Versions 1.0-1.3 were distributed to participants in RSA Data
   Security, Inc.'s Public-Key Cryptography Standards meetings in
   February and March 1991.






Kaliski                      Informational                     [Page 17]
 
RFC 2313                PKCS #1: RSA Encryption               March 1998


   Version 1.4

   Version 1.4 is part of the June 3, 1991 initial public release of
   PKCS. Version 1.4 was published as NIST/OSI Implementors' Workshop
   document SEC-SIG-91-18.

   Version 1.5

   Version 1.5 incorporates several editorial changes, including updates
   to the references and the addition of a revision history. The
   following substantive changes were made:

        o    Section 10: "MD4 with RSA" signature and
             verification processes are added.

        o    Section 11: md4WithRSAEncryption object identifier
             is added.

   Supersedes June 3, 1991 version, which was also published as NIST/OSI
   Implementors' Workshop document SEC-SIG-91-18.

Acknowledgements

   This document is based on a contribution of RSA Laboratories, a
   division of RSA Data Security, Inc.  Any substantial use of the text
   from this document must acknowledge RSA Data Security, Inc. RSA Data
   Security, Inc.  requests that all material mentioning or referencing
   this document identify this as "RSA Data Security, Inc. PKCS #1".

Author's Address

   Burt Kaliski
   RSA Laboratories East
   20 Crosby Drive
   Bedford, MA  01730

   Phone: (617) 687-7000
   EMail: burt@rsa.com













Kaliski                      Informational                     [Page 18]
 
RFC 2313                PKCS #1: RSA Encryption               March 1998


Full Copyright Statement

   Copyright (C) The Internet Society (1998).  All Rights Reserved.

   This document and translations of it may be copied and furnished to
   others, and derivative works that comment on or otherwise explain it
   or assist in its implementation may be prepared, copied, published
   and distributed, in whole or in part, without restriction of any
   kind, provided that the above copyright notice and this paragraph are
   included on all such copies and derivative works.  However, this
   document itself may not be modified in any way, such as by removing
   the copyright notice or references to the Internet Society or other
   Internet organizations, except as needed for the purpose of
   developing Internet standards in which case the procedures for
   copyrights defined in the Internet Standards process must be
   followed, or as required to translate it into languages other than
   English.

   The limited permissions granted above are perpetual and will not be
   revoked by the Internet Society or its successors or assigns.

   This document and the information contained herein is provided on an
   "AS IS" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING
   TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING
   BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION
   HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF
   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.
























Kaliski                      Informational                     [Page 19]


Html markup produced by rfcmarkup 1.127, available from https://tools.ietf.org/tools/rfcmarkup/


